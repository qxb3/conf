#!/usr/bin/gjs -m
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// ../../../../../../../usr/share/astal/gjs/overrides.ts
var snakeify = (str) => str.replace(/([a-z])([A-Z])/g, "$1_$2").replaceAll("-", "_").toLowerCase();
async function suppress(mod, patch2) {
  return mod.then((m) => patch2(m.default)).catch(() => void 0);
}
function patch(proto, prop) {
  Object.defineProperty(proto, prop, {
    get() {
      return this[`get_${snakeify(prop)}`]();
    }
  });
}
await suppress(import("gi://AstalApps"), ({ Apps, Application }) => {
  patch(Apps.prototype, "list");
  patch(Application.prototype, "keywords");
  patch(Application.prototype, "categories");
});
await suppress(import("gi://AstalBattery"), ({ UPower }) => {
  patch(UPower.prototype, "devices");
});
await suppress(import("gi://AstalBluetooth"), ({ Adapter, Bluetooth, Device }) => {
  patch(Adapter.prototype, "uuids");
  patch(Bluetooth.prototype, "adapters");
  patch(Bluetooth.prototype, "devices");
  patch(Device.prototype, "uuids");
});
await suppress(import("gi://AstalHyprland"), ({ Hyprland: Hyprland3, Monitor, Workspace }) => {
  patch(Hyprland3.prototype, "monitors");
  patch(Hyprland3.prototype, "workspaces");
  patch(Hyprland3.prototype, "clients");
  patch(Monitor.prototype, "availableModes");
  patch(Monitor.prototype, "available_modes");
  patch(Workspace.prototype, "clients");
});
await suppress(import("gi://AstalMpris"), ({ Mpris: Mpris4, Player }) => {
  patch(Mpris4.prototype, "players");
  patch(Player.prototype, "supported_uri_schemes");
  patch(Player.prototype, "supportedUriSchemes");
  patch(Player.prototype, "supported_mime_types");
  patch(Player.prototype, "supportedMimeTypes");
  patch(Player.prototype, "comments");
});
await suppress(import("gi://AstalNetwork"), ({ Wifi }) => {
  patch(Wifi.prototype, "access_points");
  patch(Wifi.prototype, "accessPoints");
});
await suppress(import("gi://AstalNotifd"), ({ Notifd, Notification }) => {
  patch(Notifd.prototype, "notifications");
  patch(Notification.prototype, "actions");
});
await suppress(import("gi://AstalPowerProfiles"), ({ PowerProfiles }) => {
  patch(PowerProfiles.prototype, "actions");
});
await suppress(import("gi://AstalWp"), ({ Wp: Wp2, Audio, Video }) => {
  patch(Wp2.prototype, "endpoints");
  patch(Wp2.prototype, "devices");
  patch(Audio.prototype, "streams");
  patch(Audio.prototype, "recorders");
  patch(Audio.prototype, "microphones");
  patch(Audio.prototype, "speakers");
  patch(Audio.prototype, "devices");
  patch(Video.prototype, "streams");
  patch(Video.prototype, "recorders");
  patch(Video.prototype, "sinks");
  patch(Video.prototype, "sources");
  patch(Video.prototype, "devices");
});

// ../../../../../../../usr/share/astal/gjs/index.ts
import { default as default3 } from "gi://AstalIO?version=0.1";

// ../../../../../../../usr/share/astal/gjs/process.ts
import Astal from "gi://AstalIO";
var { Process } = Astal;
function subprocess(argsOrCmd, onOut = print, onErr = printerr) {
  const args = Array.isArray(argsOrCmd) || typeof argsOrCmd === "string";
  const { cmd, err, out } = {
    cmd: args ? argsOrCmd : argsOrCmd.cmd,
    err: args ? onErr : argsOrCmd.err || onErr,
    out: args ? onOut : argsOrCmd.out || onOut
  };
  const proc = Array.isArray(cmd) ? Astal.Process.subprocessv(cmd) : Astal.Process.subprocess(cmd);
  proc.connect("stdout", (_, stdout) => out(stdout));
  proc.connect("stderr", (_, stderr) => err(stderr));
  return proc;
}
function exec(cmd) {
  return Array.isArray(cmd) ? Astal.Process.execv(cmd) : Astal.Process.exec(cmd);
}
function execAsync(cmd) {
  return new Promise((resolve, reject) => {
    if (Array.isArray(cmd)) {
      Astal.Process.exec_asyncv(cmd, (_, res) => {
        try {
          resolve(Astal.Process.exec_asyncv_finish(res));
        } catch (error) {
          reject(error);
        }
      });
    } else {
      Astal.Process.exec_async(cmd, (_, res) => {
        try {
          resolve(Astal.Process.exec_finish(res));
        } catch (error) {
          reject(error);
        }
      });
    }
  });
}

// ../../../../../../../usr/share/astal/gjs/time.ts
import Astal2 from "gi://AstalIO";
var { Time } = Astal2;
function interval(interval2, callback) {
  return Astal2.Time.interval(interval2, () => void callback?.());
}

// ../../../../../../../usr/share/astal/gjs/file.ts
import Astal3 from "gi://AstalIO";
import Gio from "gi://Gio?version=2.0";
function monitorFile(path, callback) {
  return Astal3.monitor_file(path, (file, event) => {
    callback(file, event);
  });
}

// ../../../../../../../usr/share/astal/gjs/gobject.ts
import GObject from "gi://GObject";
import { default as default2 } from "gi://GLib?version=2.0";
var meta = Symbol("meta");
var priv = Symbol("priv");
var { ParamSpec, ParamFlags } = GObject;
var kebabify = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").replaceAll("_", "-").toLowerCase();
function register(options = {}) {
  return function(cls) {
    const t = options.Template;
    if (typeof t === "string" && !t.startsWith("resource://") && !t.startsWith("file://")) {
      options.Template = new TextEncoder().encode(t);
    }
    GObject.registerClass({
      Signals: { ...cls[meta]?.Signals },
      Properties: { ...cls[meta]?.Properties },
      ...options
    }, cls);
    delete cls[meta];
  };
}
function property(declaration = Object) {
  return function(target, prop, desc) {
    target.constructor[meta] ??= {};
    target.constructor[meta].Properties ??= {};
    const name = kebabify(prop);
    if (!desc) {
      Object.defineProperty(target, prop, {
        get() {
          return this[priv]?.[prop] ?? defaultValue(declaration);
        },
        set(v) {
          if (v !== this[prop]) {
            this[priv] ??= {};
            this[priv][prop] = v;
            this.notify(name);
          }
        }
      });
      Object.defineProperty(target, `set_${name.replace("-", "_")}`, {
        value(v) {
          this[prop] = v;
        }
      });
      Object.defineProperty(target, `get_${name.replace("-", "_")}`, {
        value() {
          return this[prop];
        }
      });
      target.constructor[meta].Properties[kebabify(prop)] = pspec(name, ParamFlags.READWRITE, declaration);
    } else {
      let flags = 0;
      if (desc.get) flags |= ParamFlags.READABLE;
      if (desc.set) flags |= ParamFlags.WRITABLE;
      target.constructor[meta].Properties[kebabify(prop)] = pspec(name, flags, declaration);
    }
  };
}
function pspec(name, flags, declaration) {
  if (declaration instanceof ParamSpec)
    return declaration;
  switch (declaration) {
    case String:
      return ParamSpec.string(name, "", "", flags, "");
    case Number:
      return ParamSpec.double(name, "", "", flags, -Number.MAX_VALUE, Number.MAX_VALUE, 0);
    case Boolean:
      return ParamSpec.boolean(name, "", "", flags, false);
    case Object:
      return ParamSpec.jsobject(name, "", "", flags);
    default:
      return ParamSpec.object(name, "", "", flags, declaration.$gtype);
  }
}
function defaultValue(declaration) {
  if (declaration instanceof ParamSpec)
    return declaration.get_default_value();
  switch (declaration) {
    case String:
      return "";
    case Number:
      return 0;
    case Boolean:
      return false;
    case Object:
    default:
      return null;
  }
}

// ../../../../../../../usr/share/astal/gjs/binding.ts
var snakeify2 = (str) => str.replace(/([a-z])([A-Z])/g, "$1_$2").replaceAll("-", "_").toLowerCase();
var kebabify2 = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").replaceAll("_", "-").toLowerCase();
var Binding = class _Binding {
  transformFn = (v) => v;
  #emitter;
  #prop;
  static bind(emitter, prop) {
    return new _Binding(emitter, prop);
  }
  constructor(emitter, prop) {
    this.#emitter = emitter;
    this.#prop = prop && kebabify2(prop);
  }
  toString() {
    return `Binding<${this.#emitter}${this.#prop ? `, "${this.#prop}"` : ""}>`;
  }
  as(fn) {
    const bind2 = new _Binding(this.#emitter, this.#prop);
    bind2.transformFn = (v) => fn(this.transformFn(v));
    return bind2;
  }
  get() {
    if (typeof this.#emitter.get === "function")
      return this.transformFn(this.#emitter.get());
    if (typeof this.#prop === "string") {
      const getter = `get_${snakeify2(this.#prop)}`;
      if (typeof this.#emitter[getter] === "function")
        return this.transformFn(this.#emitter[getter]());
      return this.transformFn(this.#emitter[this.#prop]);
    }
    throw Error("can not get value of binding");
  }
  subscribe(callback) {
    if (typeof this.#emitter.subscribe === "function") {
      return this.#emitter.subscribe(() => {
        callback(this.get());
      });
    } else if (typeof this.#emitter.connect === "function") {
      const signal = `notify::${this.#prop}`;
      const id = this.#emitter.connect(signal, () => {
        callback(this.get());
      });
      return () => {
        this.#emitter.disconnect(id);
      };
    }
    throw Error(`${this.#emitter} is not bindable`);
  }
};
var { bind } = Binding;

// ../../../../../../../usr/share/astal/gjs/variable.ts
import Astal4 from "gi://AstalIO";
var VariableWrapper = class extends Function {
  variable;
  errHandler = console.error;
  _value;
  _poll;
  _watch;
  pollInterval = 1e3;
  pollExec;
  pollTransform;
  pollFn;
  watchTransform;
  watchExec;
  constructor(init) {
    super();
    this._value = init;
    this.variable = new Astal4.VariableBase();
    this.variable.connect("dropped", () => {
      this.stopWatch();
      this.stopPoll();
    });
    this.variable.connect("error", (_, err) => this.errHandler?.(err));
    return new Proxy(this, {
      apply: (target, _, args) => target._call(args[0])
    });
  }
  _call(transform) {
    const b = Binding.bind(this);
    return transform ? b.as(transform) : b;
  }
  toString() {
    return String(`Variable<${this.get()}>`);
  }
  get() {
    return this._value;
  }
  set(value) {
    if (value !== this._value) {
      this._value = value;
      this.variable.emit("changed");
    }
  }
  startPoll() {
    if (this._poll)
      return;
    if (this.pollFn) {
      this._poll = interval(this.pollInterval, () => {
        const v = this.pollFn(this.get());
        if (v instanceof Promise) {
          v.then((v2) => this.set(v2)).catch((err) => this.variable.emit("error", err));
        } else {
          this.set(v);
        }
      });
    } else if (this.pollExec) {
      this._poll = interval(this.pollInterval, () => {
        execAsync(this.pollExec).then((v) => this.set(this.pollTransform(v, this.get()))).catch((err) => this.variable.emit("error", err));
      });
    }
  }
  startWatch() {
    if (this._watch)
      return;
    this._watch = subprocess({
      cmd: this.watchExec,
      out: (out) => this.set(this.watchTransform(out, this.get())),
      err: (err) => this.variable.emit("error", err)
    });
  }
  stopPoll() {
    this._poll?.cancel();
    delete this._poll;
  }
  stopWatch() {
    this._watch?.kill();
    delete this._watch;
  }
  isPolling() {
    return !!this._poll;
  }
  isWatching() {
    return !!this._watch;
  }
  drop() {
    this.variable.emit("dropped");
  }
  onDropped(callback) {
    this.variable.connect("dropped", callback);
    return this;
  }
  onError(callback) {
    delete this.errHandler;
    this.variable.connect("error", (_, err) => callback(err));
    return this;
  }
  subscribe(callback) {
    const id = this.variable.connect("changed", () => {
      callback(this.get());
    });
    return () => this.variable.disconnect(id);
  }
  poll(interval2, exec2, transform = (out) => out) {
    this.stopPoll();
    this.pollInterval = interval2;
    this.pollTransform = transform;
    if (typeof exec2 === "function") {
      this.pollFn = exec2;
      delete this.pollExec;
    } else {
      this.pollExec = exec2;
      delete this.pollFn;
    }
    this.startPoll();
    return this;
  }
  watch(exec2, transform = (out) => out) {
    this.stopWatch();
    this.watchExec = exec2;
    this.watchTransform = transform;
    this.startWatch();
    return this;
  }
  observe(objs, sigOrFn, callback) {
    const f = typeof sigOrFn === "function" ? sigOrFn : callback ?? (() => this.get());
    const set = (obj, ...args) => this.set(f(obj, ...args));
    if (Array.isArray(objs)) {
      for (const obj of objs) {
        const [o, s] = obj;
        const id = o.connect(s, set);
        this.onDropped(() => o.disconnect(id));
      }
    } else {
      if (typeof sigOrFn === "string") {
        const id = objs.connect(sigOrFn, set);
        this.onDropped(() => objs.disconnect(id));
      }
    }
    return this;
  }
  static derive(deps, fn = (...args) => args) {
    const update = () => fn(...deps.map((d) => d.get()));
    const derived = new Variable(update());
    const unsubs = deps.map((dep) => dep.subscribe(() => derived.set(update())));
    derived.onDropped(() => unsubs.map((unsub) => unsub()));
    return derived;
  }
};
var Variable = new Proxy(VariableWrapper, {
  apply: (_t, _a, args) => new VariableWrapper(args[0])
});
var variable_default = Variable;

// globals.ts
var user = exec(`whoami`);
var homeDir = exec(`bash -c 'echo $HOME'`);
Object.assign(globalThis, {
  USER: user,
  HOME_DIR: homeDir,
  TMP: `/tmp`,
  CPU_POLL: 5e3,
  RAM_POLL: 5e3,
  DISKS_POLL: 6e5,
  ANIMATION_SPEED: 100
});

// ../../../../../../../usr/share/astal/gjs/gtk3/index.ts
import Astal8 from "gi://Astal?version=3.0";
import Gtk4 from "gi://Gtk?version=3.0";
import Gdk from "gi://Gdk?version=3.0";

// ../../../../../../../usr/share/astal/gjs/gtk3/astalify.ts
import Astal5 from "gi://Astal?version=3.0";
import Gtk from "gi://Gtk?version=3.0";
import GObject2 from "gi://GObject";
function mergeBindings(array) {
  function getValues(...args) {
    let i = 0;
    return array.map(
      (value) => value instanceof Binding ? args[i++] : value
    );
  }
  const bindings = array.filter((i) => i instanceof Binding);
  if (bindings.length === 0)
    return array;
  if (bindings.length === 1)
    return bindings[0].as(getValues);
  return variable_default.derive(bindings, getValues)();
}
function setProp(obj, prop, value) {
  try {
    const setter = `set_${snakeify2(prop)}`;
    if (typeof obj[setter] === "function")
      return obj[setter](value);
    return obj[prop] = value;
  } catch (error) {
    console.error(`could not set property "${prop}" on ${obj}:`, error);
  }
}
function astalify(cls, clsName = cls.name) {
  class Widget extends cls {
    get css() {
      return Astal5.widget_get_css(this);
    }
    set css(css) {
      Astal5.widget_set_css(this, css);
    }
    get_css() {
      return this.css;
    }
    set_css(css) {
      this.css = css;
    }
    get className() {
      return Astal5.widget_get_class_names(this).join(" ");
    }
    set className(className) {
      Astal5.widget_set_class_names(this, className.split(/\s+/));
    }
    get_class_name() {
      return this.className;
    }
    set_class_name(className) {
      this.className = className;
    }
    get cursor() {
      return Astal5.widget_get_cursor(this);
    }
    set cursor(cursor) {
      Astal5.widget_set_cursor(this, cursor);
    }
    get_cursor() {
      return this.cursor;
    }
    set_cursor(cursor) {
      this.cursor = cursor;
    }
    get clickThrough() {
      return Astal5.widget_get_click_through(this);
    }
    set clickThrough(clickThrough) {
      Astal5.widget_set_click_through(this, clickThrough);
    }
    get_click_through() {
      return this.clickThrough;
    }
    set_click_through(clickThrough) {
      this.clickThrough = clickThrough;
    }
    get noImplicitDestroy() {
      return this.__no_implicit_destroy;
    }
    set noImplicitDestroy(value) {
      this.__no_implicit_destroy = value;
    }
    _setChildren(children) {
      children = children.flat(Infinity).map((ch) => ch instanceof Gtk.Widget ? ch : new Gtk.Label({ visible: true, label: String(ch) }));
      if (this instanceof Gtk.Bin) {
        const ch = this.get_child();
        if (ch)
          this.remove(ch);
        if (ch && !children.includes(ch) && !this.noImplicitDestroy)
          ch?.destroy();
      } else if (this instanceof Gtk.Container) {
        for (const ch of this.get_children()) {
          this.remove(ch);
          if (!children.includes(ch) && !this.noImplicitDestroy)
            ch?.destroy();
        }
      }
      if (this instanceof Astal5.Box) {
        this.set_children(children);
      } else if (this instanceof Astal5.Stack) {
        this.set_children(children);
      } else if (this instanceof Astal5.CenterBox) {
        this.startWidget = children[0];
        this.centerWidget = children[1];
        this.endWidget = children[2];
      } else if (this instanceof Astal5.Overlay) {
        const [child, ...overlays] = children;
        this.set_child(child);
        this.set_overlays(overlays);
      } else if (this instanceof Gtk.Container) {
        for (const ch of children)
          this.add(ch);
      } else {
        throw Error(`can not add children to ${this.constructor.name}, it is not a container widget`);
      }
    }
    toggleClassName(cn, cond = true) {
      Astal5.widget_toggle_class_name(this, cn, cond);
    }
    hook(object, signalOrCallback, callback) {
      if (typeof object.connect === "function" && callback) {
        const id = object.connect(signalOrCallback, (_, ...args) => {
          callback(this, ...args);
        });
        this.connect("destroy", () => {
          object.disconnect(id);
        });
      } else if (typeof object.subscribe === "function" && typeof signalOrCallback === "function") {
        const unsub = object.subscribe((...args) => {
          signalOrCallback(this, ...args);
        });
        this.connect("destroy", unsub);
      }
      return this;
    }
    constructor(...params) {
      super();
      const [config] = params;
      const { setup, child, children = [], ...props } = config;
      props.visible ??= true;
      if (child)
        children.unshift(child);
      const bindings = Object.keys(props).reduce((acc, prop) => {
        if (props[prop] instanceof Binding) {
          const binding = props[prop];
          delete props[prop];
          return [...acc, [prop, binding]];
        }
        return acc;
      }, []);
      const onHandlers = Object.keys(props).reduce((acc, key) => {
        if (key.startsWith("on")) {
          const sig = kebabify2(key).split("-").slice(1).join("-");
          const handler = props[key];
          delete props[key];
          return [...acc, [sig, handler]];
        }
        return acc;
      }, []);
      const mergedChildren = mergeBindings(children.flat(Infinity));
      if (mergedChildren instanceof Binding) {
        this._setChildren(mergedChildren.get());
        this.connect("destroy", mergedChildren.subscribe((v) => {
          this._setChildren(v);
        }));
      } else {
        if (mergedChildren.length > 0) {
          this._setChildren(mergedChildren);
        }
      }
      for (const [signal, callback] of onHandlers) {
        if (typeof callback === "function") {
          this.connect(signal, callback);
        } else {
          this.connect(signal, () => execAsync(callback).then(print).catch(console.error));
        }
      }
      for (const [prop, binding] of bindings) {
        if (prop === "child" || prop === "children") {
          this.connect("destroy", binding.subscribe((v) => {
            this._setChildren(v);
          }));
        }
        this.connect("destroy", binding.subscribe((v) => {
          setProp(this, prop, v);
        }));
        setProp(this, prop, binding.get());
      }
      Object.assign(this, props);
      setup?.(this);
    }
  }
  GObject2.registerClass({
    GTypeName: `Astal_${clsName}`,
    Properties: {
      "class-name": GObject2.ParamSpec.string(
        "class-name",
        "",
        "",
        GObject2.ParamFlags.READWRITE,
        ""
      ),
      "css": GObject2.ParamSpec.string(
        "css",
        "",
        "",
        GObject2.ParamFlags.READWRITE,
        ""
      ),
      "cursor": GObject2.ParamSpec.string(
        "cursor",
        "",
        "",
        GObject2.ParamFlags.READWRITE,
        "default"
      ),
      "click-through": GObject2.ParamSpec.boolean(
        "click-through",
        "",
        "",
        GObject2.ParamFlags.READWRITE,
        false
      ),
      "no-implicit-destroy": GObject2.ParamSpec.boolean(
        "no-implicit-destroy",
        "",
        "",
        GObject2.ParamFlags.READWRITE,
        false
      )
    }
  }, Widget);
  return Widget;
}

// ../../../../../../../usr/share/astal/gjs/gtk3/app.ts
import Gtk2 from "gi://Gtk?version=3.0";
import Astal6 from "gi://Astal?version=3.0";

// ../../../../../../../usr/share/astal/gjs/_app.ts
import { setConsoleLogDomain } from "console";
import { exit, programArgs } from "system";
import IO from "gi://AstalIO";
import GObject3 from "gi://GObject";
function mkApp(App) {
  return new class AstalJS extends App {
    static {
      GObject3.registerClass({ GTypeName: "AstalJS" }, this);
    }
    eval(body) {
      return new Promise((res, rej) => {
        try {
          const fn = Function(`return (async function() {
                        ${body.includes(";") ? body : `return ${body};`}
                    })`);
          fn()().then(res).catch(rej);
        } catch (error) {
          rej(error);
        }
      });
    }
    requestHandler;
    vfunc_request(msg, conn) {
      if (typeof this.requestHandler === "function") {
        this.requestHandler(msg, (response) => {
          IO.write_sock(
            conn,
            String(response),
            (_, res) => IO.write_sock_finish(res)
          );
        });
      } else {
        super.vfunc_request(msg, conn);
      }
    }
    apply_css(style, reset = false) {
      super.apply_css(style, reset);
    }
    quit(code) {
      super.quit();
      exit(code ?? 0);
    }
    start({ requestHandler: requestHandler2, css, hold, main, client, icons, ...cfg } = {}) {
      const app = this;
      client ??= () => {
        print(`Astal instance "${app.instanceName}" already running`);
        exit(1);
      };
      Object.assign(this, cfg);
      setConsoleLogDomain(app.instanceName);
      this.requestHandler = requestHandler2;
      app.connect("activate", () => {
        main?.(...programArgs);
      });
      try {
        app.acquire_socket();
      } catch (error) {
        return client((msg) => IO.send_message(app.instanceName, msg), ...programArgs);
      }
      if (css)
        this.apply_css(css, false);
      if (icons)
        app.add_icons(icons);
      hold ??= true;
      if (hold)
        app.hold();
      app.runAsync([]);
    }
  }();
}

// ../../../../../../../usr/share/astal/gjs/gtk3/app.ts
Gtk2.init(null);
var app_default = mkApp(Astal6.Application);

// ../../../../../../../usr/share/astal/gjs/gtk3/widget.ts
import Astal7 from "gi://Astal?version=3.0";
import Gtk3 from "gi://Gtk?version=3.0";
import GObject4 from "gi://GObject";
Object.defineProperty(Astal7.Box.prototype, "children", {
  get() {
    return this.get_children();
  },
  set(v) {
    this.set_children(v);
  }
});
var Box = class extends astalify(Astal7.Box) {
  static {
    GObject4.registerClass({ GTypeName: "Box" }, this);
  }
  constructor(props, ...children) {
    super({ children, ...props });
  }
};
var Button = class extends astalify(Astal7.Button) {
  static {
    GObject4.registerClass({ GTypeName: "Button" }, this);
  }
  constructor(props, child) {
    super({ child, ...props });
  }
};
var CenterBox = class extends astalify(Astal7.CenterBox) {
  static {
    GObject4.registerClass({ GTypeName: "CenterBox" }, this);
  }
  constructor(props, ...children) {
    super({ children, ...props });
  }
};
var CircularProgress = class extends astalify(Astal7.CircularProgress) {
  static {
    GObject4.registerClass({ GTypeName: "CircularProgress" }, this);
  }
  constructor(props, child) {
    super({ child, ...props });
  }
};
var DrawingArea = class extends astalify(Gtk3.DrawingArea) {
  static {
    GObject4.registerClass({ GTypeName: "DrawingArea" }, this);
  }
  constructor(props) {
    super(props);
  }
};
var Entry = class extends astalify(Gtk3.Entry) {
  static {
    GObject4.registerClass({ GTypeName: "Entry" }, this);
  }
  constructor(props) {
    super(props);
  }
};
var EventBox = class extends astalify(Astal7.EventBox) {
  static {
    GObject4.registerClass({ GTypeName: "EventBox" }, this);
  }
  constructor(props, child) {
    super({ child, ...props });
  }
};
var Icon = class extends astalify(Astal7.Icon) {
  static {
    GObject4.registerClass({ GTypeName: "Icon" }, this);
  }
  constructor(props) {
    super(props);
  }
};
var Label = class extends astalify(Astal7.Label) {
  static {
    GObject4.registerClass({ GTypeName: "Label" }, this);
  }
  constructor(props) {
    super(props);
  }
};
var LevelBar = class extends astalify(Astal7.LevelBar) {
  static {
    GObject4.registerClass({ GTypeName: "LevelBar" }, this);
  }
  constructor(props) {
    super(props);
  }
};
Object.defineProperty(Astal7.Overlay.prototype, "overlays", {
  get() {
    return this.get_overlays();
  },
  set(v) {
    this.set_overlays(v);
  }
});
var Overlay = class extends astalify(Astal7.Overlay) {
  static {
    GObject4.registerClass({ GTypeName: "Overlay" }, this);
  }
  constructor(props, ...children) {
    super({ children, ...props });
  }
};
var Revealer = class extends astalify(Gtk3.Revealer) {
  static {
    GObject4.registerClass({ GTypeName: "Revealer" }, this);
  }
  constructor(props, child) {
    super({ child, ...props });
  }
};
var Scrollable = class extends astalify(Astal7.Scrollable) {
  static {
    GObject4.registerClass({ GTypeName: "Scrollable" }, this);
  }
  constructor(props, child) {
    super({ child, ...props });
  }
};
var Slider = class extends astalify(Astal7.Slider) {
  static {
    GObject4.registerClass({ GTypeName: "Slider" }, this);
  }
  constructor(props) {
    super(props);
  }
};
var Stack = class extends astalify(Astal7.Stack) {
  static {
    GObject4.registerClass({ GTypeName: "Stack" }, this);
  }
  constructor(props, ...children) {
    super({ children, ...props });
  }
};
var Switch = class extends astalify(Gtk3.Switch) {
  static {
    GObject4.registerClass({ GTypeName: "Switch" }, this);
  }
  constructor(props) {
    super(props);
  }
};
var Window = class extends astalify(Astal7.Window) {
  static {
    GObject4.registerClass({ GTypeName: "Window" }, this);
  }
  constructor(props, child) {
    super({ child, ...props });
  }
};

// cssHotReload.ts
function compileScss() {
  try {
    exec(`sass ${"/home/qxb3/.config/ags"}/styles.scss ${TMP}/styles.css`);
    app_default.apply_css("/tmp/styles.css");
    return `${TMP}/styles.scss`;
  } catch (err) {
    printerr("Error compiling scss files.", err);
    return "";
  }
}
(function() {
  const scssFiles = exec(`find -L ${"/home/qxb3/.config/ags"} -iname '*.scss'`).split("\n");
  compileScss();
  scssFiles.forEach(
    (file) => monitorFile(file, compileScss)
  );
})();

// windows/statusline/StatusLine.tsx
import Hyprland2 from "gi://AstalHyprland";
import Battery from "gi://AstalBattery";

// widgets/BatteryIcon.tsx
import BatteryService from "gi://AstalBattery";

// ../../../../../../../usr/share/astal/gjs/gtk3/jsx-runtime.ts
function isArrowFunction(func) {
  return !Object.hasOwn(func, "prototype");
}
function jsx(ctor, { children, ...props }) {
  children ??= [];
  if (!Array.isArray(children))
    children = [children];
  children = children.filter(Boolean);
  if (children.length === 1)
    props.child = children[0];
  else if (children.length > 1)
    props.children = children;
  if (typeof ctor === "string") {
    return new ctors[ctor](props);
  }
  if (isArrowFunction(ctor))
    return ctor(props);
  return new ctor(props);
}
var ctors = {
  box: Box,
  button: Button,
  centerbox: CenterBox,
  circularprogress: CircularProgress,
  drawingarea: DrawingArea,
  entry: Entry,
  eventbox: EventBox,
  // TODO: fixed
  // TODO: flowbox
  icon: Icon,
  label: Label,
  levelbar: LevelBar,
  // TODO: listbox
  overlay: Overlay,
  revealer: Revealer,
  scrollable: Scrollable,
  slider: Slider,
  stack: Stack,
  switch: Switch,
  window: Window
};
var jsxs = jsx;

// widgets/BatteryIcon.tsx
var battery = BatteryService.get_default();
function BatteryIcon({ name = "", className = "" }) {
  return /* @__PURE__ */ jsx(
    "box",
    {
      name,
      halign: Gtk4.Align.CENTER,
      children: bind(battery, "charging").as((charging) => /* @__PURE__ */ jsx(
        "label",
        {
          className,
          label: bind(battery, "percentage").as((percentage) => {
            percentage *= 100;
            if (!charging) {
              if (percentage < 5) return "\u{F008E}";
              if (percentage < 10) return "\u{F007A}";
              if (percentage < 20) return "\u{F007B}";
              if (percentage < 30) return "\u{F007C}";
              if (percentage < 40) return "\u{F007D}";
              if (percentage < 50) return "\u{F007E}";
              if (percentage < 60) return "\u{F007F}";
              if (percentage < 70) return "\u{F0080}";
              if (percentage < 80) return "\u{F0081}";
              if (percentage < 90) return "\u{F0082}";
              if (percentage <= 100) return "\u{F0079}";
            }
            if (charging) {
              if (percentage < 10) return "\u{F089C}";
              if (percentage < 20) return "\u{F0086}";
              if (percentage < 30) return "\u{F0087}";
              if (percentage < 40) return "\u{F0088}";
              if (percentage < 50) return "\u{F089D}";
              if (percentage < 60) return "\u{F0089}";
              if (percentage < 70) return "\u{F089E}";
              if (percentage < 80) return "\u{F008A}";
              if (percentage < 90) return "\u{F008B}";
              if (percentage <= 100) return "\u{F0085}";
            }
          })
        }
      ))
    }
  );
}

// widgets/StatusLineDivider.tsx
function StatusLineDivider(props) {
  const { divider = "\uE621", margin = 5, visible = true } = props;
  return /* @__PURE__ */ jsx(
    "label",
    {
      label: divider,
      visible,
      css: `
        font-weight: 900;
        margin: 0 ${margin}px;
      `
    }
  );
}

// windows/statusline/modes/NormalMode.tsx
import Hyprland from "gi://AstalHyprland";
import Mpris from "gi://AstalMpris";
var hyprland = Hyprland.get_default();
var spotify = Mpris.Player.new("spotify");
function NormalMode() {
  return /* @__PURE__ */ jsxs(
    "box",
    {
      name: "normal",
      className: "normal",
      spacing: 8,
      hexpand: true,
      children: [
        /* @__PURE__ */ jsxs(
          "stack",
          {
            className: "window_state",
            transitionType: Gtk4.StackTransitionType.OVER_RIGHT_LEFT,
            transitionDuration: ANIMATION_SPEED,
            setup: (self) => {
              self.hook(hyprland, "event", () => {
                const focusedClient = hyprland.get_focused_client();
                if (!focusedClient) {
                  self.set_shown("tiling");
                  return;
                }
                self.set_shown(
                  !focusedClient.get_floating() ? "tiling" : "floating"
                );
              });
            },
            children: [
              /* @__PURE__ */ jsx(
                "label",
                {
                  name: "tiling",
                  className: "tiling",
                  label: "TILING"
                }
              ),
              /* @__PURE__ */ jsx(
                "label",
                {
                  name: "floating",
                  className: "floating",
                  label: "FLOATING"
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsx(
          "label",
          {
            className: "active_window",
            setup: (self) => {
              self.hook(hyprland, "event", () => {
                const focusedClient = hyprland.get_focused_client();
                self.set_label(
                  focusedClient ? focusedClient.get_class() : "~"
                );
              });
            }
          }
        ),
        /* @__PURE__ */ jsx(
          "label",
          {
            className: "decoration",
            label: "[+]"
          }
        ),
        /* @__PURE__ */ jsx(StatusLineDivider, {}),
        bind(spotify, "available").as(
          (musicAvailable) => !musicAvailable ? /* @__PURE__ */ jsx(
            "label",
            {
              className: "music_indicator",
              label: "\u{F075B} No Music - Title"
            }
          ) : /* @__PURE__ */ jsx(
            "label",
            {
              className: "music_indicator",
              label: bind(spotify, "title").as((title) => `\u{F075A} Playing - ${title}`)
            }
          )
        )
      ]
    }
  );
}

// windows/statusline/modes/CommandMode.tsx
import Notifyd from "gi://AstalNotifd";

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register2(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register2(ExtendedSearch);
}

// windows/statusline/vars.ts
var statusLineMode = Variable("normal");

// windows/statusline/modes/MenuMode.tsx
function ItemsMenu(props) {
  const { gdkmonitor, child, children } = props;
  return /* @__PURE__ */ jsx(
    "window",
    {
      namespace: "astal_menu_mode",
      application: app_default,
      gdkmonitor,
      anchor: Astal8.WindowAnchor.LEFT | Astal8.WindowAnchor.BOTTOM,
      setup: (self) => app_default.add_window(self),
      children: /* @__PURE__ */ jsx(
        "box",
        {
          className: "menu_mode_menu",
          vertical: true,
          children: child ?? children
        }
      )
    }
  );
}
function MenuMode(props) {
  const {
    gdkmonitor,
    mode,
    items,
    keys,
    queriedItems,
    selectedItem,
    selectedIndex: selectedIndex4,
    maxResult = 15,
    onEnter,
    child,
    children
  } = props;
  const fuse = new Fuse(items, {
    useExtendedSearch: true,
    includeMatches: true,
    keys
  });
  return /* @__PURE__ */ jsxs(
    "box",
    {
      name: mode,
      className: `menu ${mode}`,
      children: [
        /* @__PURE__ */ jsx("label", { label: ":" }),
        /* @__PURE__ */ jsx(
          "entry",
          {
            onChanged: ({ text }) => {
              if (!text) queriedItems.set(items.slice(0, maxResult));
              else queriedItems.set(
                fuse.search(text).map(({ item }) => item).slice(0, maxResult)
              );
              selectedItem.set(queriedItems.get()[0]);
              selectedIndex4.set(0);
            },
            onKeyPressEvent: (_, event) => {
              const keyval = event.get_keyval().pop();
              const queried = queriedItems.get();
              const index = selectedIndex4.get();
              switch (keyval) {
                case Gdk.KEY_Escape:
                  return statusLineMode.set("normal");
                case Gdk.KEY_Tab:
                case Gdk.KEY_Down:
                  if (!queried) return;
                  if (index < queried.length - 1) {
                    selectedIndex4.set(index + 1);
                    selectedItem.set(queried[selectedIndex4.get()]);
                  }
                  break;
                case Gdk.KEY_Up:
                  if (!queried) return;
                  if (index > 0) {
                    selectedIndex4.set(index - 1);
                    selectedItem.set(queried[selectedIndex4.get()]);
                  }
                  break;
                case 65293:
                  onEnter(selectedItem.get());
                  statusLineMode.set("normal");
                  break;
              }
            },
            setup: (self) => {
              const Menu = ItemsMenu({ gdkmonitor, children, child });
              Menu.set_visible(false);
              self.hook(statusLineMode, () => {
                if (statusLineMode.get() !== mode) {
                  Menu.set_visible(false);
                  self.text = "";
                  selectedItem.set(queriedItems.get()[0]);
                  selectedIndex4.set(0);
                  return;
                }
                Menu.set_visible(true);
                self.grab_focus();
              });
            }
          }
        )
      ]
    }
  );
}

// windows/statusline/modes/CommandMode.tsx
var notifyd = Notifyd.get_default();
var availableCommands = [
  { name: "shutdown", fn: () => execAsync(`systemctl poweroff`) },
  { name: "restart", fn: () => execAsync(`systemctl reboot`) },
  { name: "suspend", fn: () => execAsync(`bash -c 'systemctl suspend && hyprlock'`) },
  { name: "logout", fn: () => execAsync(`hyprctl dispatch exit`) },
  { name: "clear-notif", fn: () => notifyd.get_notifications().forEach((n) => n.dismiss()) }
];
var queriedCommands = Variable(availableCommands);
var selectedCommand = Variable(queriedCommands.get()[0]);
var selectedIndex = Variable(0);
function CommandMode(props) {
  const { gdkmonitor } = props;
  return /* @__PURE__ */ jsx(
    MenuMode,
    {
      gdkmonitor,
      mode: "command",
      items: availableCommands,
      keys: ["name"],
      queriedItems: queriedCommands,
      selectedItem: selectedCommand,
      selectedIndex,
      onEnter: (selectedCommand2) => {
        selectedCommand2.fn();
      },
      children: queriedCommands((commands) => commands.map((command) => /* @__PURE__ */ jsx(
        "box",
        {
          className: selectedCommand(
            (selectedCmd) => selectedCmd.name === command.name ? "selected item" : "item"
          ),
          children: /* @__PURE__ */ jsx(
            "label",
            {
              className: "name",
              label: command.name,
              truncate: true
            }
          )
        }
      )))
    }
  );
}

// windows/statusline/modes/WallpapersMode.tsx
var wallpapers = exec(`bash -c "find -L ~/.config/swww -iname '*.png'"`).split("\n").map((path) => ({
  name: path.split("/").pop(),
  path
}));
var queriedWallpapers = Variable(wallpapers);
var selectedWallpaper = Variable(queriedWallpapers.get()[0]);
var selectedIndex2 = Variable(0);
function WallpapersMode(props) {
  const { gdkmonitor } = props;
  return /* @__PURE__ */ jsx(
    MenuMode,
    {
      gdkmonitor,
      mode: "wallpapers",
      items: wallpapers,
      keys: ["name"],
      queriedItems: queriedWallpapers,
      selectedItem: selectedWallpaper,
      selectedIndex: selectedIndex2,
      onEnter: (selectedWallpaper2) => {
        execAsync(`
          swww img ${selectedWallpaper2.path}
            --transition-type "none"
            --transition-duration 0
        `);
      },
      children: queriedWallpapers((wallpapers2) => wallpapers2.map((wallpaper) => /* @__PURE__ */ jsx(
        "box",
        {
          className: selectedWallpaper(
            (selectedCmd) => selectedCmd.name === wallpaper.name ? "selected item" : "item"
          ),
          children: /* @__PURE__ */ jsx(
            "label",
            {
              className: "name",
              label: wallpaper.name,
              truncate: true
            }
          )
        }
      )))
    }
  );
}

// windows/statusline/modes/AppLauncherMode.tsx
import Applications from "gi://AstalApps";
var MAX_RESULT = 15;
var applications = new Applications.Apps().fuzzy_query("");
var queriedApps = Variable(applications.slice(0, MAX_RESULT));
var selectedApp = Variable(queriedApps.get()[0]);
var selectedIndex3 = Variable(0);
function AppLauncherMode(props) {
  const { gdkmonitor } = props;
  return /* @__PURE__ */ jsx(
    MenuMode,
    {
      gdkmonitor,
      mode: "appLauncher",
      items: applications,
      keys: [
        "name",
        "description",
        "entry",
        "keywords",
        "categories",
        "wm-class"
      ],
      queriedItems: queriedApps,
      selectedItem: selectedApp,
      selectedIndex: selectedIndex3,
      maxResult: MAX_RESULT,
      onEnter: (selectedApp2) => {
        selectedApp2.launch();
      },
      children: queriedApps((apps) => apps.map((app) => /* @__PURE__ */ jsx(
        "box",
        {
          className: selectedApp(
            (selectedApp2) => selectedApp2.get_name() === app.get_name() ? "selected item" : "item"
          ),
          children: /* @__PURE__ */ jsx(
            "label",
            {
              className: "name",
              label: app.get_name(),
              truncate: true
            }
          )
        }
      )))
    }
  );
}

// windows/statusline/StatusLine.tsx
var hyprland2 = Hyprland2.get_default();
var battery2 = Battery.get_default();
var time = Variable("").poll(1e3, `date "+%I : %M %p"`);
function RightSection() {
  return /* @__PURE__ */ jsxs("box", { className: "right", children: [
    /* @__PURE__ */ jsx(
      "label",
      {
        className: "decoration",
        label: "\uEBC6"
      }
    ),
    /* @__PURE__ */ jsx(StatusLineDivider, {}),
    /* @__PURE__ */ jsxs("box", { visible: bind(battery2, "isPresent"), children: [
      /* @__PURE__ */ jsxs(
        "box",
        {
          className: "battery",
          halign: Gtk4.Align.CENTER,
          spacing: 8,
          children: [
            /* @__PURE__ */ jsx(BatteryIcon, { className: "icon" }),
            /* @__PURE__ */ jsx(
              "label",
              {
                className: "percentage",
                label: bind(battery2, "percentage").as((percentage) => `${Math.floor(percentage * 100)}%`)
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsx(StatusLineDivider, {})
    ] }),
    /* @__PURE__ */ jsx(
      "label",
      {
        className: "user",
        label: USER
      }
    ),
    /* @__PURE__ */ jsx(
      "label",
      {
        className: "time_indicator",
        label: time()
      }
    ),
    /* @__PURE__ */ jsx(
      "stack",
      {
        className: "mode_indicator",
        shown: "workspace",
        transitionType: Gtk4.StackTransitionType.OVER_RIGHT_LEFT,
        transitionDuration: ANIMATION_SPEED,
        children: /* @__PURE__ */ jsx(
          "label",
          {
            name: "workspace",
            className: "workspace",
            label: bind(hyprland2, "focusedWorkspace").as((workspace) => `${workspace.get_id()}:0`)
          }
        )
      }
    )
  ] });
}
function StatusLine(props) {
  const { gdkmonitor } = props;
  return /* @__PURE__ */ jsxs("box", { className: "statusline", children: [
    /* @__PURE__ */ jsxs("stack", { shown: statusLineMode(), children: [
      /* @__PURE__ */ jsx(NormalMode, {}),
      /* @__PURE__ */ jsx(AppLauncherMode, { gdkmonitor }),
      /* @__PURE__ */ jsx(CommandMode, { gdkmonitor }),
      /* @__PURE__ */ jsx(WallpapersMode, { gdkmonitor })
    ] }),
    /* @__PURE__ */ jsx(RightSection, {})
  ] });
}
function StatusLine_default(gdkmonitor) {
  return /* @__PURE__ */ jsx(
    "window",
    {
      name: "statusline",
      namespace: "astal_statusline",
      application: app_default,
      gdkmonitor,
      exclusivity: Astal8.Exclusivity.EXCLUSIVE,
      layer: Astal8.Layer.TOP,
      anchor: Astal8.WindowAnchor.LEFT | Astal8.WindowAnchor.RIGHT | Astal8.WindowAnchor.BOTTOM,
      keymode: statusLineMode(
        (mode) => mode === "normal" ? Astal8.Keymode.NONE : Astal8.Keymode.EXCLUSIVE
      ),
      children: /* @__PURE__ */ jsx(StatusLine, { gdkmonitor })
    }
  );
}

// windows/file_explorer/vars.ts
var revealFileExplorer = Variable(false);

// windows/file_explorer/utils.tsx
function createTree(tree) {
  const generatedTree = [];
  function traverse(current, nested) {
    const space = /* @__PURE__ */ jsx(
      "label",
      {
        label: "  ".repeat(nested)
      }
    );
    generatedTree.push(
      /* @__PURE__ */ jsxs("box", { className: "item", children: [
        current.type === 0 /* DIR */ && /* @__PURE__ */ jsxs("box", { className: `dir ${current.name}`, children: [
          space,
          /* @__PURE__ */ jsx(
            "label",
            {
              className: "down",
              label: "\uEAB4"
            }
          ),
          /* @__PURE__ */ jsx(
            "label",
            {
              className: "text",
              label: `${current.icon ?? "\uE5FE"} ${current.name}`
            }
          )
        ] }),
        current.type === 1 /* FILE */ && /* @__PURE__ */ jsxs("box", { className: `file ${current.name}`, children: [
          space,
          /* @__PURE__ */ jsx(
            "label",
            {
              className: "text",
              label: `${current.icon ?? "\uE612"} ${current.name} -> ${current.value}`
            }
          )
        ] }),
        current.type === 2 /* WIDGET */ && /* @__PURE__ */ jsxs("box", { className: `widget ${current.name}`, children: [
          space,
          /* @__PURE__ */ jsx(
            "label",
            {
              className: "text",
              label: `${current.icon ?? "\uE612"} ${current.name} -> `
            }
          ),
          current.widget
        ] }),
        current.type === 3 /* CUSTOM */ && /* @__PURE__ */ jsxs("box", { className: "custom", children: [
          space,
          current.widget
        ] })
      ] })
    );
    if (current.type === 0 /* DIR */) {
      for (const item of current.children) {
        traverse(item, nested + 1);
      }
    }
  }
  traverse(tree, 0);
  return generatedTree;
}

// windows/file_explorer/folders/fetch.tsx
var pkgs = Variable(getPkgs()).poll(1e4, () => getPkgs());
var uptime = Variable(getUptime()).poll(1e3, () => getUptime());
function getGpus() {
  return exec(
    `bash -c "lspci | grep -i 'vga\\|3d' | awk -F ': ' '{print $2}' | sed -E 's/.*(HD Graphics.*|GeForce.*|Radeon.*)[^)]*/\\1/'"`
  ).replace(/\(.*\)|\]/g, "").split("\n").map((gpu, i) => ({
    type: 1 /* FILE */,
    name: `gpu${i}`,
    icon: "\u{F0296}",
    value: gpu
  }));
}
function getPkgs() {
  return exec(
    `bash -c "pacman -Q | wc -l"`
  );
}
function getUptime() {
  return exec(
    `bash -c "uptime -p | awk '{print $2, $3}' | cut -d ',' -f1"`
  );
}
var fetch = {
  type: 0 /* DIR */,
  name: "fetch",
  children: [
    {
      type: 1 /* FILE */,
      name: "device",
      icon: "\u{F0322}",
      value: exec(
        `bash -c "hostnamectl | grep 'Hardware Model' | awk -F ': ' '{print $2}'"`
      )
    },
    {
      type: 1 /* FILE */,
      name: "cpu",
      icon: "\uF4BC",
      value: exec(
        `bash -c "lscpu | grep 'Model name' | awk -F: '{print $2}' | sed -E 's/^[ 	]*| CPU.*$//g' | sed -E 's/(R)|(TM)//g'"`
      ).trim().replaceAll("()", "")
    },
    ...getGpus(),
    {
      type: 1 /* FILE */,
      name: "user",
      icon: "\uF4FF",
      value: USER
    },
    {
      type: 2 /* WIDGET */,
      name: "pkgs",
      icon: "\u{F03D3}",
      widget: /* @__PURE__ */ jsx(
        "label",
        {
          label: pkgs()
        }
      )
    },
    {
      type: 2 /* WIDGET */,
      name: "uptime",
      icon: "\u{F1446}",
      widget: /* @__PURE__ */ jsx(
        "label",
        {
          label: uptime()
        }
      )
    }
  ]
};
var fetch_default = fetch;

// widgets/ProgressBar.ts
var ProgressBar = class extends astalify(Gtk4.ProgressBar) {
  static {
    GObject.registerClass(this);
  }
  constructor(props) {
    super(props);
  }
};

// windows/file_explorer/folders/stats.tsx
var cpu = Variable(getCpu()).poll(CPU_POLL, () => getCpu());
var ram = Variable(getRam()).poll(RAM_POLL, () => getRam());
var disks = Variable(getDisks()).poll(DISKS_POLL, () => getDisks());
function getCpu() {
  const cpu2 = exec(`top -b -n 1`).split("\n").find((line) => line.includes("Cpu(s)")).split(/\s+/)[1].replace(",", ".");
  return parseFloat(cpu2) / 100;
}
function getRam() {
  const [total, used] = exec(`free`).split("\n").find((line) => line.includes("Mem:")).split(/\s+/).splice(1, 2);
  return parseFloat(used) / parseFloat(total);
}
function getDisks() {
  return exec("df -h").split("\n").filter((line) => line.includes("/") && !line.includes("tmpfs")).map((line) => {
    const partition = line.split(/\s+/)[5];
    const [size, used] = line.split(/\s+/).slice(1, 3).map((line2) => parseFloat(line2.replace("G", "")));
    return {
      partition,
      size,
      used
    };
  });
}
var stats = {
  type: 0 /* DIR */,
  name: "stats",
  children: [
    {
      type: 2 /* WIDGET */,
      name: "cpu",
      icon: "\uF4BC",
      widget: /* @__PURE__ */ jsxs("box", { children: [
        /* @__PURE__ */ jsx("label", { label: "[" }),
        /* @__PURE__ */ jsx(
          ProgressBar,
          {
            className: "metric",
            fraction: cpu()
          }
        ),
        /* @__PURE__ */ jsx("label", { label: "]" })
      ] })
    },
    {
      type: 2 /* WIDGET */,
      name: "ram",
      icon: "\uE266",
      widget: /* @__PURE__ */ jsxs("box", { children: [
        /* @__PURE__ */ jsx("label", { label: "[" }),
        /* @__PURE__ */ jsx(
          ProgressBar,
          {
            className: "metric",
            fraction: ram()
          }
        ),
        /* @__PURE__ */ jsx("label", { label: "]" })
      ] })
    },
    {
      type: 0 /* DIR */,
      name: "disks",
      children: disks.get().map((disk, i) => {
        return {
          type: 2 /* WIDGET */,
          name: disk.partition,
          icon: "\u{F0249}",
          widget: /* @__PURE__ */ jsxs("box", { children: [
            /* @__PURE__ */ jsx("label", { label: "[" }),
            /* @__PURE__ */ jsx(
              ProgressBar,
              {
                className: "metric",
                fraction: disks((disks2) => {
                  const disk2 = disks2[i];
                  return disk2.used / disk2.size;
                })
              }
            ),
            /* @__PURE__ */ jsx("label", { label: "]" })
          ] })
        };
      })
    }
  ]
};
var stats_default = stats;

// windows/file_explorer/folders/desktop/music_player.tsx
import Mpris2 from "gi://AstalMpris";
var spotify2 = Mpris2.Player.new("spotify");
var musicPlayer = {
  type: 0 /* DIR */,
  name: "music_player",
  children: [
    {
      type: 2 /* WIDGET */,
      name: "title",
      icon: "\u{F0CB9}",
      widget: /* @__PURE__ */ jsx(
        "label",
        {
          label: bind(spotify2, "title").as((title) => title ?? "No Music"),
          maxWidthChars: 16,
          truncate: true
        }
      )
    },
    {
      type: 2 /* WIDGET */,
      name: "artist",
      icon: "\u{F0803}",
      widget: /* @__PURE__ */ jsx(
        "label",
        {
          label: bind(spotify2, "artist").as((artist) => artist ?? "Artist"),
          maxWidthChars: 16,
          truncate: true
        }
      )
    },
    {
      type: 2 /* WIDGET */,
      name: "album",
      icon: "\u{F0025}",
      widget: /* @__PURE__ */ jsx(
        "label",
        {
          label: bind(spotify2, "album").as((album) => album ?? "Album"),
          maxWidthChars: 16,
          truncate: true
        }
      )
    },
    {
      type: 2 /* WIDGET */,
      name: "controls",
      icon: "\uF1DE",
      widget: /* @__PURE__ */ jsxs(
        "box",
        {
          className: "music_controls",
          spacing: 8,
          children: [
            /* @__PURE__ */ jsx(
              "button",
              {
                cursor: "pointer",
                onClick: () => spotify2.previous(),
                children: /* @__PURE__ */ jsx("label", { label: "\u{F04AE}" })
              }
            ),
            /* @__PURE__ */ jsx(
              "button",
              {
                cursor: "pointer",
                onClick: () => spotify2.play_pause(),
                children: /* @__PURE__ */ jsx(
                  "label",
                  {
                    label: bind(spotify2, "playbackStatus").as(
                      (status) => status === Mpris2.PlaybackStatus.STOPPED ? "\u{F04DB}" : status === Mpris2.PlaybackStatus.PLAYING ? "\u{F03E4}" : "\u{F040A}"
                    )
                  }
                )
              }
            ),
            /* @__PURE__ */ jsx(
              "button",
              {
                cursor: "pointer",
                onClick: () => spotify2.next(),
                children: /* @__PURE__ */ jsx("label", { label: "\u{F04AD}" })
              }
            )
          ]
        }
      )
    }
  ]
};
var music_player_default = musicPlayer;

// windows/file_explorer/folders/desktop/desktop_controls.tsx
import Wp from "gi://AstalWp";
import Mpris3 from "gi://AstalMpris";

// services/Brightness.ts
var Brightness = class extends GObject.Object {
  get brightness() {
    return this._brightness;
  }
  set brightness(value) {
    value = Math.max(0, Math.min(value, 1));
    execAsync(`brightnessctl set ${value * 100}% -q`);
  }
  set_brightness(value) {
    this.brightness = value;
  }
  constructor() {
    super();
    this.interface = exec(`sh -c 'ls -w1 /sys/class/backlight | head -1'`).trim();
    this.interfacePath = `/sys/class/backlight/${this.interface}/brightness`;
    this.maxBrightness = Number(exec(`brightnessctl max`));
    this._brightness = Number(exec(`brightnessctl get`)) / this.maxBrightness;
    monitorFile(this.interfacePath, () => {
      this._brightness = Number(exec(`brightnessctl get`)) / this.maxBrightness;
      this.notify("brightness");
    });
  }
  static get_default() {
    return new Brightness();
  }
};
__decorateClass([
  property(String)
], Brightness.prototype, "interface", 2);
__decorateClass([
  property(String)
], Brightness.prototype, "interfacePath", 2);
__decorateClass([
  property(Number)
], Brightness.prototype, "maxBrightness", 2);
__decorateClass([
  property(Number)
], Brightness.prototype, "brightness", 1);
Brightness = __decorateClass([
  register()
], Brightness);

// windows/file_explorer/folders/desktop/desktop_controls.tsx
var audio = Wp.get_default().get_audio();
var spotify3 = Mpris3.Player.new("spotify");
var brightness = Brightness.get_default();
var desktopControls = {
  type: 0 /* DIR */,
  name: "desktop_controls",
  children: [
    {
      type: 2 /* WIDGET */,
      name: "speaker",
      icon: "\u{F057E}",
      widget: /* @__PURE__ */ jsx("box", { children: bind(audio, "defaultSpeaker").as((speaker) => /* @__PURE__ */ jsxs("box", { children: [
        /* @__PURE__ */ jsx("label", { label: "[" }),
        /* @__PURE__ */ jsx(
          "slider",
          {
            value: bind(speaker, "volume"),
            min: 0,
            max: 1.5,
            step: 0.01,
            drawValue: false,
            hexpand: true,
            cursor: "pointer",
            onDragged: ({ value }) => speaker.set_volume(value)
          }
        ),
        /* @__PURE__ */ jsx("label", { label: "]" })
      ] })) })
    },
    {
      type: 2 /* WIDGET */,
      name: "music",
      icon: "\u{F075A}",
      widget: /* @__PURE__ */ jsxs("box", { children: [
        /* @__PURE__ */ jsx("label", { label: "[" }),
        /* @__PURE__ */ jsx(
          "slider",
          {
            value: bind(spotify3, "volume"),
            min: 0,
            max: 1,
            step: 0.01,
            drawValue: false,
            hexpand: true,
            cursor: "pointer",
            onDragged: ({ value }) => spotify3.set_volume(value)
          }
        ),
        /* @__PURE__ */ jsx("label", { label: "]" })
      ] })
    },
    {
      type: 2 /* WIDGET */,
      name: "bright",
      icon: "\u{F00E0}",
      widget: /* @__PURE__ */ jsxs("box", { children: [
        /* @__PURE__ */ jsx("label", { label: "[" }),
        /* @__PURE__ */ jsx(
          "slider",
          {
            value: bind(brightness, "brightness"),
            min: 0,
            max: 1,
            step: 0.01,
            drawValue: false,
            hexpand: true,
            cursor: "pointer",
            onDragged: ({ value }) => brightness.set_brightness(value)
          }
        ),
        /* @__PURE__ */ jsx("label", { label: "]" })
      ] })
    }
  ]
};
var desktop_controls_default = desktopControls;

// windows/file_explorer/folders/desktop/notifications.tsx
import Notifyd2 from "gi://AstalNotifd";
var notifyd2 = Notifyd2.get_default();
var notifications = {
  type: 3 /* CUSTOM */,
  widget: /* @__PURE__ */ jsx("box", { vertical: true, children: bind(notifyd2, "notifications").as((notifications2) => {
    const notifs = notifications2.reduce((acc, notification) => {
      function findExistingNotif() {
        return acc.findIndex(
          (existingNotif2) => existingNotif2.type === 0 /* DIR */ && existingNotif2.name === notification.get_app_name()
        );
      }
      if (findExistingNotif() === -1) {
        acc.push({
          type: 0 /* DIR */,
          name: notification.get_app_name(),
          children: []
        });
      }
      const existingNotif = findExistingNotif();
      if (existingNotif !== -1 && acc[existingNotif].type === 0 /* DIR */) {
        acc[existingNotif].children.push({
          type: 3 /* CUSTOM */,
          widget: /* @__PURE__ */ jsx(
            "label",
            {
              label: notification.get_app_name() === "Spotify" ? `\u{F075A} Playing - ${notification.get_summary()}` : notification.get_summary(),
              maxWidthChars: 24,
              truncate: true
            }
          )
        });
      }
      return acc;
    }, []);
    return createTree({
      type: 0 /* DIR */,
      name: "notifications",
      children: notifs
    });
  }) })
};
var notifications_default = notifications;

// windows/file_explorer/FileExplorer.tsx
function FileExplorer() {
  const tree = createTree({
    type: 0 /* DIR */,
    name: "info",
    children: [
      fetch_default,
      stats_default,
      {
        type: 0 /* DIR */,
        name: "desktop",
        children: [
          music_player_default,
          desktop_controls_default,
          notifications_default
        ]
      }
    ]
  });
  return /* @__PURE__ */ jsxs(
    "box",
    {
      className: "file_explorer",
      vertical: true,
      children: [
        /* @__PURE__ */ jsx(
          "label",
          {
            className: "header",
            label: "File Explorer",
            justify: Gtk4.Justification.CENTER,
            hexpand: true
          }
        ),
        /* @__PURE__ */ jsx(
          "label",
          {
            className: "path",
            label: "~/.config/ags/windows/file_explorer",
            xalign: 0
          }
        ),
        /* @__PURE__ */ jsx(
          "box",
          {
            className: "tree",
            vertical: true,
            children: tree
          }
        )
      ]
    }
  );
}
function FileExplorer_default(gdkmonitor) {
  return /* @__PURE__ */ jsx(
    "window",
    {
      name: "sidebar",
      namespace: "astal_file_explorer",
      application: app_default,
      gdkmonitor,
      anchor: Astal8.WindowAnchor.TOP | Astal8.WindowAnchor.BOTTOM | Astal8.WindowAnchor.LEFT,
      children: /* @__PURE__ */ jsx(
        "revealer",
        {
          revealChild: revealFileExplorer(),
          transitionType: Gtk4.RevealerTransitionType.SLIDE_RIGHT,
          transitionDuration: ANIMATION_SPEED,
          children: /* @__PURE__ */ jsx(FileExplorer, {})
        }
      )
    }
  );
}

// requestHandler.ts
function handleStatusLine(args) {
  const [command, mode] = args;
  if (!command) return `err [msg="'command' is required."]`;
  if (!mode) return `err [msg="'mode' is required."]`;
  if (command === "toggle") {
    switch (mode) {
      case "normal":
        return `err [msg="cannot toggle normal mode."]`;
      case "appLauncher":
        statusLineMode.set(
          statusLineMode.get() === "appLauncher" ? "normal" : "appLauncher"
        );
        return `ok [cmd="toggle",mode="${statusLineMode.get()}"]`;
      case "command":
        statusLineMode.set(
          statusLineMode.get() === "command" ? "normal" : "command"
        );
        return `ok [cmd="toggle",mode="${statusLineMode.get()}"]`;
      case "wallpapers":
        statusLineMode.set(
          statusLineMode.get() === "wallpapers" ? "normal" : "wallpapers"
        );
        return `ok [cmd="toggle",mode="${statusLineMode.get()}"]`;
      default:
        return `err [msg="Unknown args for toggle statusline."]`;
    }
  }
  return `err [msg="Unknown args for statusline."]`;
}
function handleFileExplorer(args) {
  const [command] = args;
  if (!command) return `err [msg="'command' is required."]`;
  switch (command) {
    case "open":
      revealFileExplorer.set(true);
      return `ok [state=true']`;
    case "close":
      revealFileExplorer.set(false);
      return `ok [state=false']`;
    case "toggle":
      revealFileExplorer.set(
        !revealFileExplorer.get()
      );
      return `ok [state=${revealFileExplorer.get()}]`;
    default:
      return `err [msg="Uknown args for sidebar."]`;
  }
}
function requestHandler(request, res) {
  const args = request.split(":");
  switch (args[0]) {
    case "statusline":
      return res(handleStatusLine(args.slice(1)));
    case "file_explorer":
      return res(handleFileExplorer(args.slice(1)));
    default:
      return res("Unknown request.");
  }
}

// app.ts
app_default.start({
  css: compileScss(),
  main() {
    const mainMonitor = app_default.get_monitors().at(0);
    StatusLine_default(mainMonitor);
    FileExplorer_default(mainMonitor);
  },
  requestHandler
});
